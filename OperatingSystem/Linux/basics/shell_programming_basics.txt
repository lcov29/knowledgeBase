
============================= Operators =============================

	Test:
	test [ expression ]	returns value of expression
	[ expression ]

	Arithmetic:		use $((expression))
	+			add
	-			subtract
	*			multiplicate
	/			divide
	**			exponent
	%			modulo
	++			increment by 1
	--			decrement by 1

	Number Comparison:
	-eq			equal
	-gt			greater than
	-lt			lesser than
	-ge			greater or equal
	-le			lesser or equal

	Logical:
	!			not
	-a			and
	-o			or
	\( <expression> \)	group brackets have to be escaped with backslash

	String:
	<string>		<string> is not empty
	-n <string>		<string> does not exist or is not empty
	-z <string>		<string> does not exist or is empty
	<string1> = <string2>
	<string1> != <string2>
	<string1> > <string2>
	<string1> < <string2>
	
	Files:
	-e <file>		<file> exists
	-s <file>		size of <file> > 0
	-f <file>		<file> is a regular file
	-d <file>		<file> is a directory
	-b <file>		<file> is a block device
	-c <file>		<file> is a character based device
	-p <file>		<file> is a named-pipe
	-h <file>		<file> is a symbolic link
	-r <file>		<file> is readable for the current process
	-w <file>		<file> is writeable for the current process
	-x <file>		<file> is executable for the current process
	<file1> -ef <file2>	<file1> is a hardlink to <file2>
	<file1> -nt <file2>	<file1> is newer than <file2>
	<file1> -ot <file2>	<file1> is older than <file2>

	Bitwise:
	<<			bitwise left shift
	<<=			left shift equal
	>>			bitwise right shift
	&			And
	&=			And equal
	|			Or
	|=			Or equal
	~ 			negation
	!			not

	
============================= Insert and Output =============================

	read [options] [variables]		reads strings from stdin into [variables]
		-r				handle backslash as a character
		-a				read array variables
		-s				do not show input
		-n <number>			accept only <number> of characters as input
		-p <prompt>			show <prompt>

	Examples:
	-----------------------------------------
	|read -n 1 -p "Input: " var		|
	|echo $var				|
	|					|
	|read -r a b c				|
	|1 \ 3					|
	|echo $a $b $c				|
	|1 \ 3					|
	-----------------------------------------


	echo [options] <string, variable>
		-n				no line break after end of line
		-e				enable interpretation of special characters \<character>


	printf <format-string> <parameter>


============================= getopts and xargs =============================

	getopts <optstring> <name> [arguments]		parses positional parameters as options into $<name>, 
							parameterindex into $OPTIND and arguments into $OPTARG
		<optstring>				contains the option letters
							":" at start: enables silent-mode -> suppress error messages
							":" after option: options requires an additional argument
		<name>					variable into which the current option is parsed into
		

	Examples:
	-------------------------------------------------------------------------
	|while getopts ":abc:" option						|
	|do									|
	|   case $option in							|
	|   a) echo Option $option was called. ;;				|
	|   b) echo Option $option was called. ;;				|
	|   c) echo Option $option was called with parameter $OPTARG. ;;	|
	|   \?) echo $OPTARG invalid option ;;					|
	|   :) echo $OPTARG argument missing ;;					|
	|   esac								|
	|done									|
	-------------------------------------------------------------------------



	<cmd_1> | xargs <cmd_2>				uses stdout of <cmd_1> as arguments for <cmd_2>
